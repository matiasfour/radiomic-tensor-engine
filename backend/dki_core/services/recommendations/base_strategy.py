"""
═══════════════════════════════════════════════════════════════════════════════
BASE CLINICAL RECOMMENDATION STRATEGY
═══════════════════════════════════════════════════════════════════════════════

Abstract base class for all clinical recommendation strategies.
Implements the Strategy Pattern for pathology-specific decision support.

All concrete strategies must:
1. Implement generate_recommendations()
2. Include the mandatory LEGAL_DISCLAIMER in all outputs
3. Support configurable severity thresholds
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any


# ═══════════════════════════════════════════════════════════════════════════════
# MANDATORY LEGAL DISCLAIMER - Must appear in ALL recommendation outputs
# ═══════════════════════════════════════════════════════════════════════════════

LEGAL_DISCLAIMER = (
    "⚠️ AVISO LEGAL: Esta es una sugerencia generada por software de apoyo a la "
    "decisión clínica. La prescripción final es responsabilidad exclusiva del "
    "médico tratante. Este sistema no reemplaza el juicio clínico profesional."
)

LEGAL_DISCLAIMER_EN = (
    "⚠️ LEGAL DISCLAIMER: This is a suggestion generated by clinical decision "
    "support software. The final prescription is the sole responsibility of the "
    "treating physician. This system does not replace professional clinical judgment."
)


# ═══════════════════════════════════════════════════════════════════════════════
# SEVERITY LEVELS
# ═══════════════════════════════════════════════════════════════════════════════

class SeverityLevel(Enum):
    """Standardized severity levels across all pathologies."""
    NORMAL = "normal"
    MILD = "mild"
    MODERATE = "moderate"
    SEVERE = "severe"
    CRITICAL = "critical"
    
    @property
    def color(self) -> str:
        """CSS color for UI display."""
        colors = {
            "normal": "#22c55e",     # Green
            "mild": "#84cc16",       # Lime
            "moderate": "#f59e0b",   # Amber
            "severe": "#ef4444",     # Red
            "critical": "#7f1d1d",   # Dark red
        }
        return colors.get(self.value, "#6b7280")
    
    @property
    def priority(self) -> int:
        """Numeric priority for sorting (higher = more urgent)."""
        priorities = {
            "normal": 0,
            "mild": 1,
            "moderate": 2,
            "severe": 3,
            "critical": 4,
        }
        return priorities.get(self.value, 0)
    
    @property
    def label_es(self) -> str:
        """Spanish label."""
        labels = {
            "normal": "Normal",
            "mild": "Leve",
            "moderate": "Moderado",
            "severe": "Severo",
            "critical": "Crítico",
        }
        return labels.get(self.value, self.value)


# ═══════════════════════════════════════════════════════════════════════════════
# RECOMMENDATION DATA STRUCTURES
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class Recommendation:
    """A single clinical recommendation."""
    category: str                    # e.g., "Anticoagulation", "Imaging", "Monitoring"
    title: str                       # Short title
    description: str                 # Detailed recommendation text
    priority: int = 1                # 1=routine, 2=important, 3=urgent
    requires_specialist: bool = False
    time_sensitive: bool = False
    contraindications: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "category": self.category,
            "title": self.title,
            "description": self.description,
            "priority": self.priority,
            "requires_specialist": self.requires_specialist,
            "time_sensitive": self.time_sensitive,
            "contraindications": self.contraindications,
        }


@dataclass
class RecommendationResult:
    """Complete recommendation result with severity and suggestions."""
    pathology: str                          # e.g., "TEP", "Ischemia", "DKI"
    severity: SeverityLevel
    severity_score: float                   # Numeric score for the severity
    severity_description: str               # Human-readable severity explanation
    recommendations: List[Recommendation]
    metrics_summary: Dict[str, Any]         # Key metrics used for decision
    disclaimer: str = LEGAL_DISCLAIMER
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "pathology": self.pathology,
            "severity": {
                "level": self.severity.value,
                "label": self.severity.label_es,
                "color": self.severity.color,
                "priority": self.severity.priority,
            },
            "severity_score": self.severity_score,
            "severity_description": self.severity_description,
            "recommendations": [r.to_dict() for r in self.recommendations],
            "metrics_summary": self.metrics_summary,
            "disclaimer": self.disclaimer,
        }


# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURABLE THRESHOLDS
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class SeverityThresholds:
    """
    Configurable thresholds for severity classification.
    Allows institutions to customize based on local protocols.
    """
    mild_min: float
    moderate_min: float
    severe_min: float
    critical_min: Optional[float] = None
    
    def classify(self, value: float) -> SeverityLevel:
        """Classify a value into a severity level based on thresholds."""
        if self.critical_min is not None and value >= self.critical_min:
            return SeverityLevel.CRITICAL
        if value >= self.severe_min:
            return SeverityLevel.SEVERE
        if value >= self.moderate_min:
            return SeverityLevel.MODERATE
        if value >= self.mild_min:
            return SeverityLevel.MILD
        return SeverityLevel.NORMAL


# ═══════════════════════════════════════════════════════════════════════════════
# ABSTRACT BASE STRATEGY
# ═══════════════════════════════════════════════════════════════════════════════

class ClinicalRecommendationStrategy(ABC):
    """
    Abstract base class for clinical recommendation strategies.
    
    Each pathology (TEP, Ischemia, DKI) implements its own strategy
    with specific logic for severity classification and recommendations.
    
    Usage:
        strategy = TEPRecommendationStrategy(custom_thresholds)
        result = strategy.generate_recommendations(processing_result)
    """
    
    # Override in subclasses
    PATHOLOGY_NAME: str = "Unknown"
    PATHOLOGY_CODE: str = "UNKNOWN"
    
    def __init__(self, thresholds: Optional[Dict[str, SeverityThresholds]] = None):
        """
        Initialize strategy with optional custom thresholds.
        
        Args:
            thresholds: Dict mapping metric names to SeverityThresholds.
                       If None, uses default thresholds for the pathology.
        """
        self.custom_thresholds = thresholds or {}
        self._init_default_thresholds()
    
    @abstractmethod
    def _init_default_thresholds(self) -> None:
        """Initialize default severity thresholds for this pathology."""
        pass
    
    @abstractmethod
    def generate_recommendations(
        self, 
        processing_result: Any,
        patient_context: Optional[Dict[str, Any]] = None
    ) -> RecommendationResult:
        """
        Generate clinical recommendations based on processing results.
        
        Args:
            processing_result: ProcessingResult model instance
            patient_context: Optional dict with patient info (age, comorbidities, etc.)
                           for more personalized recommendations
        
        Returns:
            RecommendationResult with severity and recommendations
        """
        pass
    
    def get_threshold(self, metric_name: str) -> SeverityThresholds:
        """Get threshold for a metric (custom if available, else default)."""
        if metric_name in self.custom_thresholds:
            return self.custom_thresholds[metric_name]
        return self.default_thresholds.get(metric_name)
    
    def set_threshold(self, metric_name: str, thresholds: SeverityThresholds) -> None:
        """Set custom threshold for a metric."""
        self.custom_thresholds[metric_name] = thresholds
    
    def _create_result(
        self,
        severity: SeverityLevel,
        severity_score: float,
        severity_description: str,
        recommendations: List[Recommendation],
        metrics_summary: Dict[str, Any]
    ) -> RecommendationResult:
        """Helper to create RecommendationResult with mandatory disclaimer."""
        return RecommendationResult(
            pathology=self.PATHOLOGY_NAME,
            severity=severity,
            severity_score=severity_score,
            severity_description=severity_description,
            recommendations=recommendations,
            metrics_summary=metrics_summary,
            disclaimer=LEGAL_DISCLAIMER,  # Always included
        )
